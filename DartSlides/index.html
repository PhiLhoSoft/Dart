<!doctype html>
<html lang="en">

	<head>
		<meta charset="utf-8">

		<title>Dart language for Java programmers</title>

		<meta name="description" content="A presentation of the Dart language aimed at Java programmers">
		<meta name="author" content="Philippe Lhoste">

		<meta name="apple-mobile-web-app-capable" content="yes" />
		<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />

		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

		<link rel="stylesheet" href="css/reveal.css">
		<link rel="stylesheet" href="css/theme/sky-PLS.css" id="theme">

		<!-- For syntax highlighting -->
		<link rel="stylesheet" href="lib/css/github-PLS.css">

		<!-- If the query includes 'print-pdf', use the PDF print sheet -->
		<script>
			document.write( '<link rel="stylesheet" href="css/print/' + ( window.location.search.match( /print-pdf/gi ) ? 'pdf' : 'paper' ) + '.css" type="text/css" media="print">' );
		</script>

		<!--[if lt IE 9]>
		<script src="lib/js/html5shiv.js"></script>
		<![endif]-->
	</head>

	<body>

		<div class="reveal">

			<!-- Any section element inside of this container is displayed as a slide -->
			<div class="slides">

<section data-markdown><script type="text/template">
# Dart&nbsp;language<br/>for<br/>Java&nbsp;programmers
</script></section>

				<section>

<section data-markdown><script type="text/template">
## First Contact
</script></section>

<section data-markdown><script type="text/template">
### A sample class
````dart
/** An employee is a Person with an enterprise id, a department and a salary. */
class Employee extends Person implements HasId
{
  String id;
  Department department = Department.ACCOUNTING;
  int salary = Salary.MINIMUM;

  Employee(String name, String id) { this.name = name; this.id = id; }

  @override String getId() { return id; }
  int getSalary() { return salary; }
  Department getDepartment() { return department; }

  Employee setSalary(int salary)
  {
    if (salary < Salary.MINIMUM)
      this.salary = Salary.MINIMUM;
    else
      this.salary = salary;
    return this;
  }
  Employee setDepartment(Department department) { this.department = department; return this; }
  Employee changeSalary(int amount) { setSalary(salary + amount); return this; }

  @override String toString() { return name + " " + salary.toString() + " " + department.toString(); }
}
````
</script></section>

<section data-markdown><script type="text/template">
##### Used as:
````dart
Employee employee = new Employee("John J", "H2G2-42");
employee.setSalary(1500).setDepartment(Department.DEVELOPMENT);
print(employee);
employee.setDepartment(Department.ACCOUNTING).changeSalary(1000);
print(employee);
````
This looks like a Java class, but it is actually Dart code!

But there is more in Dart, we can see a more idiomatic version of this class, less verbose.
</script></section>

<section data-markdown><script type="text/template">
### An idiomatic Dart class
````dart
/// An employee is a [Person] with an enterprise id, a [Department] and a salary.
class Employee extends Person implements HasId
{
  String id;
  Department department;
  int _salary; // Now hidden behind getters and setters

  // id is automatically assigned, name is transmitted to super-class's constructor
  Employee(String name, this.id) : super.named(name);

  // Define getters and setters for salary. Still accessed as e.salary.
  int get salary => _salary;
  set salary(int s) => _salary = s < Salary.MINIMUM ? Salary.MINIMUM : s;
  // This one calls the setter behind the scene!
  void changeSalary(int amount) { salary += amount; }

  // String interpolation
  @override String toString() => "$name $salary $department";
}
````
</script></section>

<section data-markdown><script type="text/template">
##### Used as:
````dart
Employee employeeI = new Employee("John I", "H2G2-42");
employeeI ..salary = 1500 ..department = Department.DEVELOPMENT;
print(employeeI);
employeeI ..department = Department.ACCOUNTING ..changeSalary(1000);
print(employeeI);
````

As you can see, Dart code is smaller, avoiding lot of boilerplate code.
</script></section>

<section data-markdown><script type="text/template">
#### Classes used in the above code
````dart
abstract class HasId { String id; } // Interface definition. Automatically defines the accessors

class Person { final String name; Person.named(this.name); } // Named constructor

class Salary { static const int MINIMUM = 2000; } // Compile-time constant

class Department // Close of a Java enum
{
  final String name;

  static const Department DEVELOPMENT = const Department("development");
  static const Department ACCOUNTING = const Department("accounting");

  const Department(this.name); // Const constructor allows to build compile-time constant objects

  @override String toString() => name;
}
````
</script></section>

				</section>

				<section>

<section data-markdown><script type="text/template">
## Introduction
</script></section>

<section data-markdown><script type="text/template">
#### History
The Dart language has been created by Google in 2011 to help creating structured Web applications.

It aims to address the limitations and frustrations of the JavaScript language.
Its design is strongly inspired by Java with syntax goodies added in.

It just reached the version 1.0 (November 2013), implying a stabilization of syntax and features.
</script></section>

<section data-markdown><script type="text/template">
#### Typing
Dart can be strongly typed, allowing good tool support. It can be run on a specific VM or it can be compiled (or, rather, transcripted) to JavaScript, allowing to run it in any Web browser.

On the VM, it is in *checked mode*, with strong type checking.

Translated to JS, it is in *production mode*, as weakly typed as this language.

The former is faster and allows debugging and checks, like asserts; the later is faster than pure JavaScript and runs on all browsers. Checked mode (on the VM) alllows to make command-line and server-side Dart applications.

Typing is optional, even in checked mode (dynamic typing), giving the advantages of quick development of dynamic languages.
</script></section>

<section data-markdown><script type="text/template">
#### Why these slides?
The [DartLang.org](https://www.dartlang.org/) site offers a nice, detailed tour of the language. Some examples here come from there...

Since Dart took lot of features from Java, I did a shorter tour, skimming over identical features in both languages. I concentrate on the differences and improvements offered by Dart.
</script></section>

<section data-markdown><script type="text/template">
#### Is GWT condemned?
Dart is:

- Created by Google;
- Strongly typed and object-oriented;
- Looking like Java;
- Converted to JavaScript;
- To create advanced Web applications.
</script></section>

<section data-markdown><script type="text/template">
##### Dart vs. GWT
The language and goals are close of those of GWT, so GWT developers wondered if the latter will be abandoned in favor of Dart.

Google told that GWT was used inside the company's projects, and unlikely to disappear.

GWT mostly aims at Java programmers not wanting to learn a new language, so Dart covers a different ground.

Note there is a DWT project porting GWT to the Dart language...
</script></section>

<section data-markdown><script type="text/template">
#### Dart popularity

Dart is still a young language, but followed by numerous developpers, lot of them contributing packages to the official repository.

Google+ accounts: Dart is followed by 50,000+ persons, Dartisans by nearly 5,000 persons and the French account Dartlang [FR] by nearly 2,000 persons.

GWT uses it for its client relation tracking and Google Elections.
</script></section>

				</section>

				<section>

<section data-markdown><script type="text/template">
## Base syntax,<br/>common ground
</script></section>

<section data-markdown><script type="text/template">
### Comments

Line comments and block comments are identical to Java ones.

No comments...
</script></section>

<section data-markdown><script type="text/template">
### Variable declaration and assignment
````dart
String str = "foo";
int value;
value = 42;
````
Declaration with default value or explicit initialization, assignment, all familiar...
The semi-colons are mandatory.

The difference reside in the list of types. The classical numerical types, booleans, strings, collections, and classes are there.
Array indexes start at 0. Strings are immutable.

Expressions combine them and result in a value. All the classical arithmetic and boolean (binary & logical) operators are usable, with some additional ones detailed later.

Variables can be declared `final`, making them immutable (they cannot be re-assigned).
</script></section>

<section data-markdown><script type="text/template">
### Functions
````dart
int square(int x) { return x * x; }
````
Familiar, again, but there is more in Dart!
</script></section>

<section data-markdown><script type="text/template">
### Conditionals and loops

The full stuff is there: `if` and `else`, `for` loop, `while` and `do ... while`, `switch` and `case`, `break` and `continue` (they can take a label).

Dart also manages exceptions with `try / catch / finally`.
</script></section>

<section data-markdown><script type="text/template">
### Classes and interfaces

Dart use the Java syntax for classes.. They can be abstract. Interfaces are made of function signatures. Classes can implement one or more interfaces and can extend one class. They can use generic types, with same base syntax as Java.

A constructor can call another with `this()` and can call the parent's constructor with `super()`. Constructors are not inherited. They automatically call the parameterless super constructor.
Overridden methods can be marked with the `@override` annotation (lowercase!).

The `static` keyword can be used to make class-scoped variables and functions.
</script></section>

				</section>

				<section>

<section data-markdown><script type="text/template">
## The differences<br/>and improvements
</script></section>

<section data-markdown><script type="text/template">
### Comments

Block comments can be nested.

Dart supports the documentation comments, in the classical `/** ...  */` form, but also as line comments: `/// ...`.

Documentation comments use the Markdown syntax. Square braces [likeThis] can be used to create references to code entities.
</script></section>

<section data-markdown><script type="text/template">
### Variables

In variable declarations, type is optional. It can be replaced with the `var` keyword. Which can itself be replaced with the `final` or `const` keywords. In this case, in checked mode, the variable has an inferred, `dynamic` type. These modifiers can be added before an explicit type:`final` variables can be set only once, `const` variables are compile-time constants. Class-level constants must be declared `static`, ie. they cannot be instance variables.

Style guide recommends to use `var` for local (small scope) variables.

Dart doesn't have visibility keywords (private, protected) but a variable whose name starts with underscore (_) is private to its library.
</script></section>

<section data-markdown><script type="text/template">
### Identifiers

Unlike Java, but like JavaScript, Dart puts all identifiers at the same level: you cannot have a class, a function and a variable with the same name in the same scope.

This means you cannot have function overloading (same name, different parameter list).
</script></section>

				</section>

<section>

<section data-markdown><script type="text/template">
### Types

All types in Dart are classes, extending the `Object` super-class (including `int`, `bool`, etc.). This means that their default value is always `null`.

Dart has some base, built-in types, all with a literal representation.
</script></section>

<section data-markdown><script type="text/template">
#### Numbers

Can be `int` or `double`, both being sub-types of `num`. An `int` literal is a series of digits. Hexadecimal notation is supported. Big ints are supported out of the box (no special type).

Doubles are 64-bit numbers. A `double` literal is made of digits with a decimal point, supporting the scientific notation: `5.4e9`.
</script></section>

<section data-markdown><script type="text/template">
#### Booleans

Have the type `bool`, with literals being `true` or `false`.
Actually, these are the only two objects of this type.

In production mode, all objects can be seen as booleans, but only `true` is true, all other values are false.

In checked mode, using non-booleans where one is expected throws an exception. In production mode, non-booleans are coerced into boolean values.
</script></section>

<section data-markdown><script type="text/template">
#### Strings

Have the `String` type. These are Unicode (UTF-16) strings, literals can be delimited with either single or double quotes, with classical backslash escapes, including Unicode escape sequences.

A `r` (raw) prefix disables escapes and substitutions.

Tripled quotes can delimit multiline strings.
</script></section>

<section data-markdown><script type="text/template">
#### String operations

Adjacent string literals are concatenated. Strings can be concatenated with the `+` operator too. It is safe to compare strings with `==`.

Characters of a string (actually substrings) are accessible by treating them like arrays: `someString[index]`. Read-only: strings are immutable!
</script></section>

<section data-markdown><script type="text/template">
#### String interpolation

Strings literals can reference variables in the form of `$x` (x being a variable name) or `${x}` where x is an expression. These references are replaced at runtime with their value.
</script></section>

<section data-markdown><script type="text/template">
#### String examples

````dart
const NO_ESCAPE = r"Nothing\nCan Escape\u000AFrom Here!\n$notInterpolated";
final String MULTI_LINE = """
<-- Initial newline is ignored.
String interpolation is OK \u2661: $someVariable and ${2 * someVariable / 3}
Final newline is included -->
"""
"This string is added to the previous literal!";
````
</script></section>

<section data-markdown><script type="text/template">
#### Lists

Are extensible arrays, ordered group of objects. They have the same syntax as Java's arrays (0-based, indexing, .length) but literals look like JavaScript:
````dart
var list = [ 1, 3, 5, 7 ];
````
A list declared as
````dart
var list = new List(5);
````
has a fixed size.
</script></section>

<section data-markdown><script type="text/template">
#### Maps

Associate keys and values. Literals and access are in JavaScript style:
````dart
var stuff = { 'a': "one", 'b': "two" };
stuff['c'] = "three";
assert(stuff['d'] == null);
assert(stuff.length == 3);

// Typing a literal with generics
Map<String, Person> people = <String, Person>{};
````
</script></section>

<section data-markdown><script type="text/template">
#### Symbols
Represent operators or identifiers declared in the program, even after minification.

Literals are `#identifier_name`
</script></section>

</section>

<section>

<section data-markdown><script type="text/template">
### Operators

Beside the classical C-like operators, Dart offers some new ones.
</script></section>

<section data-markdown><script type="text/template">
`~/` divides two numbers, returning an integer result.

`as` casts a type to another.
````dart
(somebody as Person).firstName = "John"; // Throws an exception if somebody cannot be cast!
````
`is` is true if the object has the specified type.
````dart
if (somebody is Person) ...
````
`is!` is false if the object has the specified type.
````dart
if (somebody is! Person) alert();
````
</script></section>

<section data-markdown><script type="text/template">
`.` is the classical member access.

`..` is a cascade operator, allowing to perform multiple operations on the members of a single object.
````dart
person..eats("at Joe's")..sleeps("tonight");
````
is equivalent to
````dart
person.eats("at Joe's"); person.sleeps("tonight");
````
without the need to explicitly return `this` on these methods.
</script></section>

<section data-markdown><script type="text/template">
Dart allows to redefine operators for custom types (classes). In this case, the left-hand operand type defines the operator. This allows, for example, to define arithmetic for vector or matrix classes.
See the Class section for details.
</script></section>

</section>

<section>

<section data-markdown><script type="text/template">
### Control flow statements

As seen, the classical control flow statements are supported.
</script></section>

<section data-markdown><script type="text/template">
#### For loop

Beside the numerical `for` loop, `Iterable` classes (`List`, `Set`, etc.) support the `for in` iteration:
````dart
for (var item in collection) { doStuffWith(item); }
````
Iterables also have the `forEach()` method taking a function as parameter. See the Function section.
</script></section>

<section data-markdown><script type="text/template">
#### Assert

The `assert` statement throws an exception (`AssertionError`) if its parameter is false. They work only in checked mode, they are ignored (stripped out) in production mode.
````dart
assert(param != null);
assert(number >= 1 && number <= 100);
````
</script></section>

<section data-markdown><script type="text/template">
#### Switch / case

The `switch` statement compare integers, strings or compile-time constants (of exactly same class) using the `==` operator (must not be overridden).

Each non-empty `case` clause *must* end with a breaking statement, generally `break`, but it can also be `return`, `continue` or `throw`.

Only empty `case` clauses can fall-through. An explicit fall-through can be done with a `continue` statement with a label. A local variable defined in a `case` clause has its scope limited to the clause (no need to enclose it in braces).
</script></section>

<section data-markdown><script type="text/template">
##### Switch / case example
````dart
switch (state)
{
  case 'START':
    state = 'RUNNING';
    break; // OK
  case 'RUNNING':
    run();
    // Error here!
  case 'RUNNING_SPECIAL_CASE':
    var foo = getInformation(); // Local variable with scope limited to this case
    processSpecialCase(foo);
    break;
  case 'SPECIAL1': // OK here
  case 'SPECIAL2':
    manageSpecialCases(state);
    continue toClosed; // Explicit fall-through
toClosed:
  case 'CLOSED':
    dispose();
    return;
  default: // Catch-all clause
    throw "Illegal state!";
}
````
</script></section>

<section data-markdown><script type="text/template">
### Exceptions

Exception mechanism is similar to the one in Java, except there is no checked exceptions: you are not required to catch them.

Dart provides `Exception` and `Error` types (and subtypes) that you can extend but actually you can throw any non-null object as exception!
</script></section>

<section data-markdown><script type="text/template">
##### Exception example
````dart
try
{
  doStuffThrowingExceptions();
}
on IllegalArgumentException catch (e)
{
  // Use the e exception object
}
on IllegalStateException
{
  // When you don't need the object
}
on Exception catch(e)
{
  // Catch all other Exception subtypes
  rethrow; // Let the upper level to catch it
}
catch (any)
{
  // Catch all other objects than could have been thrown
}
````
</script></section>

</section>

<section>

<section data-markdown><script type="text/template">
### Functions

These are important in Dart, and have many syntax goodies.

Base syntax looks like:
````dart
void doStuff(int number) { print("I do stuff with $number."); }
````
In this form, types can be omitted but style guide recommends to put them.

For simple functions, a shorthand syntax is available:
````dart
doStuff(number) => print("I do stuff with $number.");
present(person) => "My name is ${person.name}";
````
Types can be added but style guide recommends to omit them...

There can be only one expression (not a statement) after the `=>`.
Note that void functions still return null, so a call of them is an expression.
</script></section>

<section data-markdown><script type="text/template">
#### Functions (con't)

Dart doesn't have functions with variable number of arguments, but it is easy to replace with a list literal.

As seen, Dart functions cannot be overloaded (same name, different parameters) but its optional parameters features (see below) compensates for this.

All functions return a value. If no return value is specified, it returns a `null`.
</script></section>

<section data-markdown><script type="text/template">
#### Optional parameters

As seen, functions are not polymorphic (no function overloading). You cannot have both `foo(int x)` and `foo(int x, int y)` (nor `foo(String s)`). But functions can have optional parameters after the required ones.

These optional parameters are either positional or named. Both forms accept default values, which must be compile-time constants (defined with `const`).
</script></section>

<section data-markdown><script type="text/template">
#### Named optional parameters
Named optional parameters are defined between soft braces:
````dart
void setFlags({ bool bold, bool hidden }) { ... }
````
and they can have default values:
````dart
void setFlags({ bool bold: false, bool hidden: false }) { ... }
````
They are called as:
````dart
setFlags(bold: true); // bold is true, hidden is false
````
</script></section>

<section data-markdown><script type="text/template">
#### Positional optional parameters

Positional optional parameters are defined between square brackets:
````dart
String build(String one, [ String two, String three ])
{
  String result = "Making $one";
  if (two != null)
  {
    result = "$result with $two";
    if (three != null)
    {
      result = "$result and even with $three";
    }
  }
  return result;
}
````
called as:
````dart
build("First"); // ==> Making First
build("First", "Second"); // ==> Making First with Second
build("First", "Second", "Third"); // ==> Making First with Second and even with Third
````
</script></section>

<section data-markdown><script type="text/template">
#### Positional optional parameters (con't)

Positional parameters can have default values too:
````dart
String build(String one, [ String two = "second one", String three ])
{
  // idem
}
````
</script></section>

<section data-markdown><script type="text/template">
#### main()

All Dart apps have a top-level `main()` function, entry point to the application. It returns `void` and has an optional `List<String>` parameter for command-line arguments.
</script></section>

<section data-markdown><script type="text/template">
#### Functions as first-class objects

Functions are first-class objects, ie. they can be assigned to a variable, passed as function parameter, stored in a collection, etc.

Functions can be defined inside another function. They can be named (declaring a final variable with that name) or anonymous.
</script></section>

<section data-markdown><script type="text/template">
#### First-class objects: example
````dart
void bar({ int x, int y })
{
  toString(v) { return v == null ? '' : v.toString(); }

  if (x != null || y != null)
  {
    print("bar: ${toString(x)} and ${toString(y)}");
  }
}

void jaPrint(String word)
{
  print("ja" + word);
}
var list = [ "I", "am", "a", "robot" ];
list.forEach(jaPrint); // Here is the forEach mentioned above!

var foo = jaPrint;
foo("renaming");

var onTheFly = (message) => "Speak up: ${message.toUpperCase()}!";
print(onTheFly("important sentence"));
````
An anonymous function is made with a parameter list (can be empty), followed by `=>` and an expression.
</script></section>

<section data-markdown><script type="text/template">
#### Lexical closures

A *closure* is a function object that has access to variables in its lexical scope, even when the function is used outside of its original scope.
````dart
Function prefixerMaker(String prefix)
{
  prefixer(String word)
  {
    return prefix + word;
  }
  return prefixer;
}

main()
{
  var prefixer1 = prefixerMaker('ja');
  var prefixer2 = prefixerMaker('doh-');

  assert(prefixer1("pan") == "japan");
  assert(prefixer2("Omer") == "doh-Omer");
}
````
The `prefixer()` closes over the `prefix` parameter, it is associated with its value when it is returned.
</script></section>

<section data-markdown><script type="text/template">
#### Closures over for-loop

Functions can also close over the iteration variables of a for loop, as if they were function parameters.
````dart
  var closures = [];
  for (int i = 1, j = 100; i < 5; i++, j -= 10)
  {
    closures.add((v) => j + i * v);
  }
  for (var f in closures)
  {
    print(f(3));
  }
````
Prints out 103,96, 89, 82
</script></section>

</section>

<section>

<section data-markdown><script type="text/template">
### Classes, interfaces, and more

Functions and data in a class are members of the class and are called *methods* and *instance variables*.

When a class provides a constant constructor, we can create  a compile-time constant instance using `const` instead of `new`.
````dart
var p = const Vector(1, 2);
````
Such constant can be used as default parameter. Their instance is unique:
````dart
var q = const Vector(1, 2);
assert(identical(p, q)); // Same instance
````
</script></section>

<section data-markdown><script type="text/template">
#### Instance variables

As seen, instance variables are always public. But actually, they generate an implicit *getter* method. Non-final instance variables also generate an implicit *setter* method. When needed, these accessors can be overridden.
</script></section>

<section data-markdown><script type="text/template">
#### Constructors

The classical form of constructors is supported:
````dart
class Point
{
  int x;
  int y;

  Point(int x, int y)
  {
    this.x = x;
    this.y = y;
  }
}
````
As in Java, the style guide recommends using `this` only to disambiguate variable names.
</script></section>

<section data-markdown><script type="text/template">
##### Initialization constructors

Since this pattern is very common, Dart made a shortcut for it:
````dart
class Point
{
  int x;
  int y;

  Point(this.x, this.y);
}
````
</script></section>

<section data-markdown><script type="text/template">
##### Constructor overloading

As seen, Dart doesn't allow function overloading, so it provides named constructors for alternatives:
````dart
class Point
{
  int x;
  int y;

  Point(this.x, this.y);

  Point.fromJson(Map json)
  {
    x = json['x'];
    y = json['y'];
  }
}
````
</script></section>

<section data-markdown><script type="text/template">
##### Constructors with init list

A constructor can set instances variables before the constructor body runs, by using an initialize list:
````dart
class Point
{
  int x;
  int y;

  Point(this.x, this.y);

  Point.fromJson(Map json) : x = json['x'], y = json['y']
  {
    otherInit();
  }
}
````
</script></section>

<section data-markdown><script type="text/template">
##### Calling other constructor

A constructor can call its parent's constructor:
````dart
class Point3D extends Point
{
  int z;

  Point3D(int x, int y, int z) : super(x, y)
  {
    this.z = z;
  }
}
````
and can just redirect to another constructor:
````dart
class Point
{
  int x;
  int y;

  Point(this.x, this.y);
  Point.onX(int x) : this(x, 0);
  Point.onY(int y) : this(0, y);
}
````
</script></section>

<section data-markdown><script type="text/template">
##### Const constructors

You can make compile-time constant objects by providing a `const` constructor.
````dart
class FixedPoint
{
  // Instance variables must be final
  final int x, y;

  const FixedPoint(this.x, this.y);

  static final FixedPoint origin = const FixedPoint(0, 0);
}
````

They are created by using `const` instead of `new`.
````dart
var p = const FixedPoint(1, 2);
````
Such constants can be used as default value for optional parameters. Identical constants are the same object:
````dart
var q = const FixedPoint(1, 2);
assert(identical(p, q)); // Same instance
assert(identical(const FixedPoint(0, 0), FixedPoint.origin));
````
</script></section>

<section data-markdown><script type="text/template">
##### Factory constructors

The `factory` keyword allows implementing a constructor that might create a new instance, or might instead return an instance from a cache, an instance of a subtype, etc.
</script></section>

<section data-markdown><script type="text/template">
##### Factory constructor example:
````dart
class Logger
{
  final String name;

  // _cache is library-private, thanks to the _ in front of its name.
  static final Map<String, Logger> _cache = <String, Logger>{};

  Logger._internal(this.name);

  factory Logger(String name)
  {
    if (_cache.containsKey(name))
      return _cache[name];

    final logger = new Logger._internal(name);
    _cache[name] = logger;
    return logger;
  }

  void log(String msg) { print(msg); }
}

var logger = new Logger('UI');
logger.log("Something happened!");
````
</script></section>

<section data-markdown><script type="text/template">
#### Methods

As in Java, instance methods can access instance variables and `this`.

Methods cannot be overloaded, but can override an inherited method.
</script></section>

<section data-markdown><script type="text/template">
#### Accessors

As seen, when we access an instance variable, we do it via implicit accessors. They can be made explicit with the `get` and `set` keywords.
````dart
class Product
{
  float price;
}
````
`Product`'s variable is accessed directly:
````dart
product.price = 42;
print("${product.price} €");
````
</script></section>

<section data-markdown><script type="text/template">
#### Accessor definition

If, one day, we must check the value when setting it, or transform it before returning it, it can be done without change to the interface:
````dart
class Product
{
  static const num VAT = 0.196;
  num priceWithoutVAT;

  // Define a new calculated property
  num get price => priceWithoutVAT * (1 + VAT);
  set price(num p) => priceWithoutVAT = p / (1 + VAT);
}
````
and it is still accessed like: `product.price = 42;`

and we can use `product.priceWithoutVAT` too.
So `get` and `set` allows to define a new virtual property (only `get` is needed for a `final` variable).
</script></section>

<section data-markdown><script type="text/template">
#### Implicit interfaces

Actually, Dart doesn't have an `interface` keyword. Every class implicitly defines an interface containing all the instance members of the class (not only methods, but also instance variables, or actually their accessors).
````dart
class Animal
{
  String name;
  Animal(this.name);
  void speak() { print("$name produces a sound!"); }
  static const String type = "animal";
}

class Duck implements Animal
{
  String name; // Must be implemented!
  void speak() { print("$name quacks!"); } // This one too
  // The constructor isn't part of the interface; neither is the const.
}
````
</script></section>

<section data-markdown><script type="text/template">
#### Abstract classes

Like in Java, we can use the `abstract` keyword to define an abstract class that cannot be instiantiated.

In an abstract class, instance methods (including getters and setters) can be abstract too, by putting a semi-colon instead of a method body.

Abstract classes with all abstract methods are equivalent to Java's interfaces.
</script></section>

<section data-markdown><script type="text/template">
#### Overridable operators

The following operators are overridable, ie. you can redefine them in a class, allowing to use the operator on instances of this class.
````
<   +   |   []
>   /   ^   []=
<=  ~/  &   ~
>=  *   <<  ==
-   %   >>
````
The corresponding assignment operators are overridden as well.
</script></section>

<section data-markdown><script type="text/template">
Example:
````dart
class Vector
{
  final num x;
  final num y;

  const Vector(this.x, this.y);

  @override Vector operator +(Vector v) // Add two vectors
  {
    return new Vector(x + v.x, y + v.y);
  }

  @override Vector operator -(Vector v) // Subtract two vectors
  {
    return new Vector(x - v.x, y - v.y);
  }

  @override String toString() => "($x, $y)";
}
````
</script></section>

<section data-markdown><script type="text/template">
Usage:
````dart
final v1 = new Vector(1, 2);
final v2 = new Vector(5, 7);

assert(v1.x == 1 && v1.y == 2);
assert((v1 + v2).x == 6 && (v1 + v2).y == 9);
assert((v2 - v1).x == 4 && (v2 - v1).y == 5);
var subv = new Vector(3.14, 2.71);
subv -= v1;
print("Overridden minus on vector: $subv");
````
</script></section>

<section data-markdown><script type="text/template">
#### Mixins

Mixins are a way to inject behavior into classes without relying on inheritance.

A mixin is a class not extending anything (except `Object`, of course), without declared constructors and without calls to `super`.

A class can use one or several mixins declared after the `with` keyword. Then the methods and variables defined in the mixin(s) become part of the class, as if imported.
</script></section>

<section data-markdown><script type="text/template">
````dart
abstract class NameBrick { String name; } // Mixin. abstract is not mandatory but makes sense...

abstract class HumanNameBrick // Mixin
{
  String firstName, middleName, lastName;

  String get fullName => "$firstName ${middleName == null ? '' : '$middleName '}$lastName";
}

abstract class AddressBrick // Mixin
{
  String addressLine1, addressLine2;
  String postalCode, city, country;

  String get formattedAddress => """
$addressLine1${addressLine2 == null ? '' : '\n$addressLine2'}
$postalCode $city - $country""";
}

abstract class CompanyEntity { String officialId; CompanyEntity(this.officialId); } // Base brick...
````
</script></section>

<section data-markdown><script type="text/template">
````dart
class Company extends CompanyEntity with NameBrick, AddressBrick  // The class must extend another to use a mixin
{
  Company(String officialId, String name) : super(officialId)
  {
    this.name = name;
  }

  @override String toString() => "Company $name (id: $officialId)";
}

class Person extends Object with HumanNameBrick, AddressBrick  // The class to extend can be Object!
{
  Person(String firstName, String lastName)
  {
    this.firstName = firstName;
    this.lastName = lastName;
  }

  @override String toString() => "My name is $lastName, $fullName.";
}
````
</script></section>

<section data-markdown><script type="text/template">
Usage:
````dart
Person p1 = new Person(25, "Demi", "Lees");
p1..addressLine1 = "Hollywood Drive" ..postalCode = "4651"
    ..city = "Los Angeles" ..country = "USA";
Person p2 = new Person(52, "Robert", "Patterson") ..middleName = "Hugh";

print(p1); print(p1.formattedAddress);
print(p2);

Company c = new Company("42-31415", "Roundabout Ltd");
c..addressLine1 = "Muholland Drive" ..postalCode = "4670"
    ..city = "Hollywood" ..country = "USA";
print(c); print(c.formattedAddress);
````
</script></section>

<section data-markdown><script type="text/template">
As you can see, the address is now fully part of both classes.

It favors composition over inheritance: a class can use several mixins, in a "has a" relation instead of "is a", but with a tighter integration than referencing a class: we can use `p1.formattedAddress` directly instead of `p1.address.formattedAddress`, for example.

This addresses the main issue of composition in Java where we have to write lot of boilerplate code to expose the methods of the inner classes as methods of the wrapper class.

Note: a mixin can define and use an abstract method, which is then defined in the class mixing it in.
</script></section>

<section data-markdown><script type="text/template">
#### Static variables and methods

As in Java, static variables (class variables) are useful for class-wide state and constants. They are not initialized until they are used (lazy initialization).

Static methods (class methods) are actually independent of their class (they have no access to `this`) and thus can be replaced with top-level functions.
Static methods can be used as compile-time constants.
</script></section>

<section data-markdown><script type="text/template">
#### Generics

The syntax is similar that the Java one, but the implementation is quite different: generics are always covariant, and they are reified, ie. their type is kept at runtime.
</script></section>

</section>

<section>

<section data-markdown><script type="text/template">
### Libraries

Dart comes with a number of libraries and you can define your own. Actually, every Dart app is a library.
Libraries can be distributed using packages.
</script></section>

<section data-markdown><script type="text/template">
#### Using libraries

The namespace of a library can be used in the scope of another library (or app), by using the `import` directive.

Examples:
````dart
import 'dart:html'; // Used in many Web apps
import 'package:userDefinedLib/utils.dart';
import 'sameFolder.dart';
````
`import` wants a URI specifying the library. All built-in libraries use the special `dart:` scheme. Other libraries can use a file system path or the `package:` scheme. The later specifies libraries provided by a package manager such as the `pub` tool.
</script></section>

<section data-markdown><script type="text/template">
##### Library prefix
To avoid potential conflicts (two libraries using the same identifier), you can specify a prefix on one or both libraries. For example, if you use two libraries defining the very common name `Node`, one can be prefixed:
````dart
import 'package:lib1/lib1.dart';
import 'package:lib2/lib2.dart' as other;

var node1 = new Node(); // Use Node from lib1
var node2 = new other.Node(); // Use Node from lib2
````
</script></section>

<section data-markdown><script type="text/template">
##### Partial library import
You can also import only part of a library:
````dart
import 'package:lib1/lib1.dart' show Node; // Import only Node
import 'package:lib2/lib2.dart' hide Node; // Import everything except Node
````
</script></section>

<section data-markdown><script type="text/template">
#### Defining libraries

To make your own library, you declare it with `library` and specify additional files with `part`.
````dart
library html_soup; // Declare this .dart file is a library named html_soup

import 'dart:hml'; // This library uses the HTML library

part 'parser.dart';
part 'query.dart';

// Main code here
````
In the `parser.dart` and the `query.dart` files:
````dart
part of html_soup;

// Code goes here
````
</script></section>

<section data-markdown><script type="text/template">
##### Library export
You can combine or re-package libraries by re-exporting part or all of them.
Example:
````dart
library foo;
yo() => print('Yo!');

// In another .dart file:
library bar;
import 'foo.dart';
export 'foo.dart' show yo; // Exposes yo() as it was its own

// When using the bar libary
import 'bar.dart';

yo(); // We can use the function defined in foo.dart
````
</script></section>

</section>

<section>

<section data-markdown><script type="text/template">
### Typedef

Functions are objects, of type `Function`. If you want more typing, indicating what are the parameter types and the return type, you need to use a typedef:
````dart
typedef int Comparator(Object a, Object b);
````
Thus, we can specify exactly the kind of function expected in a variable or parameter:
````dart
class SortedStuff
{
  Comparator comparator;

  SortedStuff(this.comparator);
}

int compare(Object a, Object b) => doTheComparison();

main()
{
  SortedStuff stuff = new SortedStuff(compare);
  assert(stuff.comparator is Function); // Still true
  assert(stuff.comparator is Comparator); // More precise
}
````
</script></section>

<section data-markdown><script type="text/template">
### Metadata (annotations)

Dart supports metadata, equivalent to Java's annotations, allowing to add information to code.
Notation is `@metadata` where `metadata` is a constant or a class with a constant constructor.

Dart has three built-in annotations: `@deprecated`, `@override` and `@proxy`.
</script></section>

<section data-markdown><script type="text/template">
#### Metadata creation

You can create your own metadata annoations. For example:
````dart
library todo;

class todo
{
  final String owner;
  final String task;

  const todo(this.owner, this.task);
}
````
Used as:
````dart
import 'todo.dart'

@todo('somebody', 'This should work!')
void muddleAround()
{
  trySomething();
}
````
</script></section>

<section data-markdown><script type="text/template">
#### Metadata usage

Metadata can appear before a library, class, typedef, type parameter, constructor, factory, function, field, parameter, or variable declaration and before an import or export directive.

This metadata can be used via introspection (`mirrors` library).
</script></section>

</section>

<section data-markdown><script type="text/template">
## Conclusion

The creators of the language admit themselves it is a plain old, a bit boring, language: it doesn't have new, exciting features like multiple return values (Lua), syntax sugar to make DSLs (Scala), advanced meta-programming (Nemerle) and similar.

Yet, it builds on a time-proved syntax, familiar to lot of developers, with some goodies to avoid verbosity, nice features like mixins and functions as first-class objects, and so on.

Its original goal to be supported natively in browsers was seen with skepticism, but the conversion to JS is effective, generating fast code!

So it is a very serious candidate for Web app dev., allowing coding in a safer, more robust way with excellent performance.
</script></section>

				<section data-background="BlueMoon.jpg">
					<h1>That's All Folk!</h1>
					<h3>by Philippe Lhoste</h3>
					<br/>
					<p style="text-align: center;">(It was the Dart Slides of the Moon...)</p>
				</section>

				<section>
<section data-markdown><script type="text/template">
Author: Philippe Lhoste &lt;PhiLho(a)GMX.net&gt; http://Phi.Lho.free.fr

Copyright (c) 2013 Philippe Lhoste / PhiLhoSoft
</script></section>

<section data-markdown><script type="text/template">
Playground...

----

# h1
## h2
### h3
#### h4
##### h5
###### h6
</script></section>
<section data-markdown><script type="text/template">
#### Testing highlight.js for Dart
````dart
library stuff;

/// Non-sense, pushing syntax to the limits, to stress syntax highlighter...
/// [Stuff] uses [variable] and [otherVariable] too.
abstract class Stuff extends Animal with NameBrick implements Product, Vector
{
	static int variable = 5, otherVariable = 6, z = 5;
	// $ is legal in identifiers
	String a$_ = "foo$variable$otherVariable\"$z bar";
	String _$b = 'bar\$\'foo${otherVariable * 7}';
	String $c_1 = """line one\"""
$variable -#- ${4 * variable / 3}
line two""";
	final String $c_2 = '''One\'''
\u2661 line with Unicode \u000A
Two''';
	final String d$d = r"d$z.f\" r'm${not interpolation}m';

	/* A constructor /* Non /**/ comment */ Nesting /***/ block /****/ comments! */
	Stuff(this.a$_, this._$b) : super('Natural');
	/** This creates a default [Stuff] object. */
	Stuff.defaultObject() : this(3.14.toString(), 42.toString());

	@override toString() => a$_;
}
````
</script></section>
				</section>
			</div>

		</div>

		<script src="lib/js/head.min.js"></script>
		<script src="js/reveal.min.js"></script>

		<script>

			// Full list of configuration options available here:
			// https://github.com/hakimel/reveal.js#configuration
			Reveal.initialize({
				width: 1000,
				height: 730,

				controls: true,
				progress: true,
				history: true,
				center: true,

				theme: Reveal.getQueryHash().theme, // available themes are in /css/theme
				transition: Reveal.getQueryHash().transition || 'default', // default/cube/page/concave/zoom/linear/fade/none

				// Parallax scrolling
				// parallaxBackgroundImage: 'https://s3.amazonaws.com/hakim-static/reveal-js/reveal-parallax-1.jpg',
				// parallaxBackgroundSize: '2100px 900px',

				// Optional libraries used to extend on reveal.js
				dependencies: [
					{ src: 'lib/js/classList.js', condition: function() { return !document.body.classList; } },
					{ src: 'plugin/markdown/marked.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
					{ src: 'plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
					{ src: 'plugin/highlight/highlight-PLS.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } },
					{ src: 'plugin/zoom-js/zoom.js', async: true, condition: function() { return !!document.body.classList; } },
					{ src: 'plugin/notes/notes.js', async: true, condition: function() { return !!document.body.classList; } }
				]
			});

		</script>

	</body>
</html>
